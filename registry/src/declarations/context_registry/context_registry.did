type Version = 
 record {
   major: nat;
   minor: nat;
   patch: nat;
 };
type VerifiedPayment = 
 record {
   amount: nat;
   blockIndex: nat;
   id: nat;
   payer: principal;
   registrationId: opt nat;
   transactionHash: opt text;
   verifiedAt: int;
 };
type UserRole = 
 variant {
   admin;
   guest;
   user;
 };
type UserProfile = record {name: text;};
type TransferResult = 
 variant {
   err: text;
   ok: nat;
 };
type SubscriptionType = 
 variant {
   basic;
   enterprise;
   premium;
 };
type Subscription = 
 record {
   createdAt: int;
   endTime: int;
   isActive: bool;
   paymentId: nat;
   registeredName: text;
   startTime: int;
   subscriptionType: SubscriptionType;
   user: principal;
 };
type SeasonStatus = 
 variant {
   active;
   cancelled;
   draft;
   ended;
 };
type Season = 
 record {
   createdAt: int;
   endTime: int;
   id: nat;
   maxNameLength: nat;
   maxNames: nat;
   minNameLength: nat;
   name: text;
   price: nat;
   startTime: int;
   status: SeasonStatus;
   updatedAt: int;
 };
type PaymentStatus = 
 variant {
   completed;
   failed;
   pending;
   refunded;
 };
type Payment = 
 record {
   amount: nat;
   createdAt: int;
   id: nat;
   payer: principal;
   status: PaymentStatus;
   subscriptionType: SubscriptionType;
   txHash: opt text;
   updatedAt: int;
 };
type NameRecord = 
 record {
   address: text;
   addressType: AddressType;
   createdAt: int;
   name: text;
   owner: text;
   seasonId: nat;
   updatedAt: int;
 };
type MigrationInfo = 
 record {
   checksum: opt text;
   fromVersion: Version;
   logs: vec text;
   success: bool;
   timestamp: int;
   toVersion: Version;
 };
type Metadata = 
 record {
   createdAt: int;
   description: text;
   image: text;
   title: text;
   updatedAt: int;
 };
type MarkdownContent = 
 record {
   content: text;
   updatedAt: int;
 };
type FileReference = 
 record {
   hash: text;
   path: text;
 };
type AddressType = 
 variant {
   canister;
   hub;
   identity;
 };
service : {
  activateSeason: (seasonId: nat) -> ();
  adminAddName: (name: text, address: text, addressType: AddressType) -> ();
  assignCallerUserRole: (user: principal, role: UserRole) -> ();
  cancelSeason: (seasonId: nat) -> ();
  checkBlockIndexUsed: (blockIndex: nat) -> (bool) query;
  createSeason: (name: text, startTime: int, endTime: int, maxNames: 
   nat, minNameLength: nat, maxNameLength: nat, price: nat) -> (nat);
  dropFileReference: (path: text) -> ();
  emergencyRollback: (targetVersion: Version) ->
   (record {
      logs: vec text;
      success: bool;
    });
  endSeason: (seasonId: nat) -> ();
  getActiveSeason: () -> (Season) query;
  getActiveSeasonInfo: () ->
   (record {
      availableNames: nat;
      price: nat;
      season: Season;
    }) query;
  getAdminCount: () -> (nat) query;
  getAdminPrincipal: () -> (opt principal) query;
  getAllAdmins: () -> (vec principal) query;
  getAllPayments: () -> (vec Payment) query;
  getCallerUserProfile: () -> (opt UserProfile) query;
  getCallerUserRole: () -> (UserRole) query;
  getCanisterAddresses: () ->
   (record {
      accountId: text;
      principalId: principal;
    }) query;
  getCanisterIcpAddress: () -> (text) query;
  getCanisterPrincipalId: () -> (principal) query;
  getCanisterVersion: () -> (Version) query;
  getCurrentTime: () -> (int) query;
  getCyclesBalance: () -> (nat) query;
  getFileReference: (path: text) -> (FileReference) query;
  getMarkdown: (name: text) -> (MarkdownContent) query;
  getMarkdownContent: (name: text) ->
   (variant {
      err: text;
      ok: MarkdownContent;
    }) query;
  getMetadata: (name: text) -> (variant {
                                  err: text;
                                  ok: Metadata;
                                }) query;
  getMetadataRecord: (name: text) -> (Metadata) query;
  getMigrationHistory: () -> (vec MigrationInfo) query;
  getNameRecord: (name: text) -> (variant {
                                    err: text;
                                    ok: NameRecord;
                                  }) query;
  getPayment: (paymentId: nat) -> (opt Payment) query;
  getPaymentByBlockIndex: (blockIndex: nat) -> (opt VerifiedPayment);
  getPaymentHistory: () -> (vec VerifiedPayment) query;
  getSeason: (seasonId: nat) -> (Season) query;
  getSubscriptionStats: () ->
   (record {
      activeSubscriptions: nat;
      basicSubscriptions: nat;
      enterpriseSubscriptions: nat;
      premiumSubscriptions: nat;
      totalSubscriptions: nat;
    }) query;
  getUpgradeInfo: () ->
   (record {
      currentVersion: Version;
      migrationHistory: vec MigrationInfo;
      totalNameRecords: nat;
      totalSeasons: nat;
    }) query;
  getUserProfile: (user: principal) -> (opt UserProfile) query;
  getUserSubscription: (user: principal) -> (opt Subscription) query;
  hasActiveSubscription: (user: principal) -> (bool) query;
  hasRegisteredName: (owner: text) -> (bool) query;
  initializeAccessControl: (canisterId: principal) -> ();
  isCallerAdmin: () -> (bool) query;
  listFileReferences: () -> (vec FileReference) query;
  listNameRecords: () -> (vec NameRecord) query;
  listSeasons: () -> (vec Season) query;
  pauseAllSubscriptions: () -> ();
  performDataMigration: (targetVersion: Version, validateIntegrity: bool) ->
   (record {
      checksum: opt text;
      logs: vec text;
      success: bool;
    });
  queryLedgerBalance: () -> (nat);
  registerFileReference: (path: text, hash: text) -> ();
  registerName: (_name: text, _address: text, _addressType: AddressType,
   _owner: text, _seasonId: nat) -> (nat);
  saveCallerUserProfile: (profile: UserProfile) -> ();
  saveMarkdown: (name: text, content: text) -> ();
  saveMetadata: (name: text, title: text, description: text, image: text) ->
   ();
  validateSystemState: () -> (record {
                                issues: vec text;
                                valid: bool;
                              }) query;
  verifyAndRegisterName: (name: text, address: text, addressType:
   AddressType, seasonId: nat, blockIndex: nat) -> (nat);
  verifyPayment: (_txHash: text, _amount: nat, _payer: principal) -> (bool);
  withdrawIcp: (to: principal, amount: nat) -> (TransferResult);
}
