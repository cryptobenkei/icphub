# Complete Guide to Plug Wallet Integration for Internet Computer Applications

## Migration from ICP Identity to Plug Wallet

This comprehensive technical guide provides everything needed to migrate an existing React application from Internet Computer's Internet Identity to Plug Wallet, covering authentication flows, SDK integration, code patterns, migration strategies, and security best practices.

## Authentication flow fundamentally different from ICP Identity

Plug Wallet and Internet Identity (II) represent two fundamentally different approaches to authentication on the Internet Computer. **Internet Identity uses device-based WebAuthn passkeys with per-dApp pseudonymous identities**, creating unique principals for each application origin to preserve privacy. Sessions are temporary (30-minute default, 30-day maximum) with delegation chains for cryptographic session management. In contrast, **Plug Wallet employs a unified identity model with a single Principal ID across all applications**, using a 12-word seed phrase with SECP256K1 cryptography. Authentication happens through a browser extension popup with persistent sessions that maintain state across applications until manually disconnected.

The core architectural difference lies in identity management: II creates `user_id = SHA-224(DER encoded public key) Â· 0x02` with origin-specific derivation, while Plug maintains one consistent principal throughout the ecosystem. This has profound implications for user data continuity - **direct identity migration is impossible due to incompatible principal derivation methods**, requiring application-layer data export/import processes.

## JavaScript and TypeScript SDK comprehensive documentation

### Installation and Setup

Plug Wallet's SDK requires GitHub Package Registry authentication since packages aren't published to NPM:

```bash
# Configure .npmrc
echo "@psychedelic:registry=https://npm.pkg.github.com" >> .npmrc

# Install core packages
yarn add @psychedelic/plug-connect    # React component (v0.2.0)
yarn add @psychedelic/plug-inpage-provider  # Browser provider
```

### Core API Architecture

The SDK exposes functionality through `window.ic.plug` with comprehensive TypeScript definitions:

```typescript
interface Window {
  ic?: {
    plug?: {
      // Connection methods
      requestConnect: (params?: {
        whitelist?: string[];
        host?: string;
        onConnectionUpdate?: () => void;
        timeout?: number;
      }) => Promise<string>;
      
      isConnected: () => Promise<boolean>;
      
      // Actor and agent management
      createAgent: (params: { whitelist: string[]; host: string }) => void;
      createActor: (params: { 
        canisterId: string; 
        interfaceFactory: IDL.InterfaceFactory 
      }) => Promise<ActorSubclass>;
      
      // Session data
      principalId?: string;
      accountId?: string;
      agent?: HttpAgent;
      
      // Transaction methods
      requestBalance: () => Promise<BalanceResponse[]>;
      requestTransfer: (params: TransferParams) => Promise<any>;
      batchTransactions: (transactions: BatchTransaction[]) => Promise<any>;
    };
  };
}
```

### Critical SDK Methods

**Connection Management** establishes wallet connection with canister whitelisting:
```typescript
const publicKey = await window.ic.plug.requestConnect({
  whitelist: ['rdmx6-jaaaa-aaaah-qbkaa-cai', 'ryjl3-tyaaa-aaaaa-aaaba-cai'],
  host: 'https://mainnet.dfinity.network',
  onConnectionUpdate: () => console.log('Connection status changed'),
  timeout: 50000
});
```

**Actor Creation** provides secure canister interaction:
```typescript
const actor = await window.ic.plug.createActor({
  canisterId: 'rdmx6-jaaaa-aaaah-qbkaa-cai',
  interfaceFactory: ({ IDL }) => {
    const Proposal = IDL.Record({
      'id': IDL.Nat64,
      'proposer': IDL.Principal,
      'status': IDL.Variant({
        'Open': IDL.Null,
        'Executed': IDL.Null,
        'Rejected': IDL.Null
      })
    });
    return IDL.Service({
      'get_proposal': IDL.Func([IDL.Nat64], [IDL.Opt(Proposal)], ['query']),
      'submit_proposal': IDL.Func([Proposal], [IDL.Nat64], [])
    });
  }
});
```

## Production-ready React integration patterns

### Custom Hook Implementation

A comprehensive `usePlugWallet` hook manages wallet state and operations:

```typescript
import { useState, useEffect, useCallback } from 'react';

interface PlugWalletState {
  isConnected: boolean;
  principal: string | null;
  agent: HttpAgent | null;
  balance: BalanceResponse[] | null;
  isConnecting: boolean;
  error: string | null;
}

export const usePlugWallet = (whitelist: string[], host = 'https://icp0.io') => {
  const [state, setState] = useState<PlugWalletState>({
    isConnected: false,
    principal: null,
    agent: null,
    balance: null,
    isConnecting: false,
    error: null,
  });

  const connect = useCallback(async () => {
    if (!window.ic?.plug) {
      setState(prev => ({ ...prev, error: 'Plug wallet not installed' }));
      return;
    }

    setState(prev => ({ ...prev, isConnecting: true, error: null }));

    try {
      const publicKey = await window.ic.plug.requestConnect({ 
        whitelist, 
        host 
      });

      if (!window.ic.plug.agent) {
        await window.ic.plug.createAgent({ whitelist, host });
      }

      const principal = await window.ic.plug.agent.getPrincipal();
      const balance = await window.ic.plug.requestBalance();
      
      setState({
        isConnected: true,
        principal: principal.toString(),
        agent: window.ic.plug.agent,
        balance,
        isConnecting: false,
        error: null,
      });
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: error.message,
        isConnecting: false,
      }));
    }
  }, [whitelist, host]);

  // Auto-reconnect on mount
  useEffect(() => {
    const checkConnection = async () => {
      if (!window.ic?.plug) return;
      
      const connected = await window.ic.plug.isConnected();
      if (connected && window.ic.plug.agent) {
        const principal = await window.ic.plug.agent.getPrincipal();
        setState(prev => ({
          ...prev,
          isConnected: true,
          principal: principal.toString(),
          agent: window.ic.plug.agent,
        }));
      }
    };
    
    checkConnection();
  }, []);

  const disconnect = useCallback(async () => {
    await window.ic.plug.disconnect();
    setState({
      isConnected: false,
      principal: null,
      agent: null,
      balance: null,
      isConnecting: false,
      error: null,
    });
  }, []);

  return { ...state, connect, disconnect };
};
```

### React Context for Global State Management

```typescript
import React, { createContext, useContext, ReactNode } from 'react';

const WalletContext = createContext<ReturnType<typeof usePlugWallet> | undefined>(undefined);

export const WalletProvider: React.FC<{ 
  children: ReactNode; 
  whitelist: string[] 
}> = ({ children, whitelist }) => {
  const walletState = usePlugWallet(whitelist);
  
  return (
    <WalletContext.Provider value={walletState}>
      {children}
    </WalletContext.Provider>
  );
};

export const useWallet = () => {
  const context = useContext(WalletContext);
  if (!context) {
    throw new Error('useWallet must be used within WalletProvider');
  }
  return context;
};
```

### Connect2IC Integration (Multi-Wallet Support)

For applications requiring multiple wallet options:

```typescript
import { createClient } from "@connect2ic/core";
import { defaultProviders } from "@connect2ic/core/providers";
import { Connect2ICProvider, ConnectButton, useConnect } from "@connect2ic/react";
import "@connect2ic/core/style.css";

const client = createClient({
  canisters: {
    backend: {
      canisterId: process.env.BACKEND_CANISTER_ID,
      idlFactory: BackendIDL,
    }
  },
  providers: defaultProviders, // Includes Plug, II, Stoic, Bitfinity
});

function App() {
  return (
    <Connect2ICProvider client={client}>
      <ConnectButton />
      <MainApp />
    </Connect2ICProvider>
  );
}
```

## Comprehensive canister interaction capabilities

Plug Wallet provides full support for ICP transfers and canister interactions through its actor system:

### ICP Transfers
```typescript
const transfer = async (to: string, amount: bigint) => {
  const result = await window.ic.plug.requestTransfer({
    to,
    amount: Number(amount), // Amount in e8s
    memo: '0',
    fee: { e8s: 10000 }, // Standard ICP fee
    from_subaccount: []
  });
  return result;
};
```

### Advanced Canister Operations
```typescript
// Batch transactions for complex operations
const batchTransactions = [
  {
    idl: TokenIDL,
    canisterId: TOKEN_CANISTER_ID,
    methodName: 'approve',
    args: [spender, amount],
    onSuccess: (res) => console.log('Approval successful'),
    onFail: (res) => console.error('Approval failed', res)
  },
  {
    idl: DEX_IDL,
    canisterId: DEX_CANISTER_ID,
    methodName: 'swap',
    args: [tokenIn, tokenOut, amountIn, minAmountOut],
    onSuccess: (res) => console.log('Swap successful'),
    onFail: (res) => console.error('Swap failed', res)
  }
];

await window.ic.plug.batchTransactions(batchTransactions);
```

## Migration strategy from ICP Identity to Plug Wallet

### Dual Authentication Support Pattern

Implement support for both authentication methods during transition:

```typescript
class AuthenticationManager {
  private authMethod: 'plug' | 'ii' | null = null;
  private identity: Identity | null = null;
  private agent: HttpAgent | null = null;

  async authenticate(method: 'plug' | 'ii') {
    this.authMethod = method;
    
    if (method === 'plug') {
      await this.authenticateWithPlug();
    } else {
      await this.authenticateWithII();
    }
  }

  private async authenticateWithPlug() {
    const connected = await window.ic.plug.requestConnect({
      whitelist: this.canisterWhitelist,
      host: this.host
    });
    
    if (connected) {
      this.agent = window.ic.plug.agent;
      this.identity = await this.agent.getPrincipal();
    }
  }

  private async authenticateWithII() {
    const authClient = await AuthClient.create();
    await authClient.login({
      identityProvider: "https://identity.internetcomputer.org",
      onSuccess: () => {
        this.identity = authClient.getIdentity();
        this.agent = new HttpAgent({ 
          identity: this.identity, 
          host: this.host 
        });
      }
    });
  }

  async createActor<T>(canisterId: string, idlFactory: IDL.InterfaceFactory): Promise<ActorSubclass<T>> {
    if (this.authMethod === 'plug') {
      return window.ic.plug.createActor({
        canisterId,
        interfaceFactory: idlFactory
      });
    } else {
      return Actor.createActor(idlFactory, {
        agent: this.agent,
        canisterId
      });
    }
  }
}
```

### Data Migration Service

Since principals differ between II and Plug, implement application-layer migration:

```typescript
class UserDataMigrationService {
  async migrateUser(oldPrincipal: Principal, newPrincipal: Principal) {
    // Step 1: Export data from old identity
    const oldActor = await this.createActorWithII(oldPrincipal);
    const userData = await oldActor.exportUserData();
    
    // Step 2: Import to new identity
    const newActor = await this.createActorWithPlug(newPrincipal);
    await newActor.importUserData({
      ...userData,
      migrationSignature: await this.generateMigrationProof(oldPrincipal, newPrincipal)
    });
    
    // Step 3: Mark old account as migrated
    await oldActor.markAsMigrated(newPrincipal);
  }

  private async generateMigrationProof(oldPrincipal: Principal, newPrincipal: Principal): Promise<Uint8Array> {
    // Generate cryptographic proof of ownership for both identities
    const message = `Migrate from ${oldPrincipal} to ${newPrincipal}`;
    // Sign with both identities to prove ownership
    return new TextEncoder().encode(message);
  }
}
```

## Robust error handling and state management

### Comprehensive Error Handler

```typescript
class PlugWalletErrorHandler {
  static ERROR_TYPES = {
    WALLET_NOT_FOUND: 'WALLET_NOT_FOUND',
    CONNECTION_REJECTED: 'CONNECTION_REJECTED',
    TRANSACTION_REJECTED: 'TRANSACTION_REJECTED',
    INSUFFICIENT_FUNDS: 'INSUFFICIENT_FUNDS',
    NETWORK_ERROR: 'NETWORK_ERROR',
    CANISTER_ERROR: 'CANISTER_ERROR',
    SESSION_EXPIRED: 'SESSION_EXPIRED',
    PERMISSION_DENIED: 'PERMISSION_DENIED'
  };

  static handleError(error: Error): ErrorResponse {
    const errorType = this.classifyError(error);
    
    const errorResponses = {
      [this.ERROR_TYPES.WALLET_NOT_FOUND]: {
        userMessage: 'Plug Wallet not detected. Please install it from Chrome Web Store.',
        action: 'INSTALL_WALLET',
        recoverable: true,
        severity: 'warning'
      },
      [this.ERROR_TYPES.CONNECTION_REJECTED]: {
        userMessage: 'Connection was rejected. Please try connecting again.',
        action: 'RETRY_CONNECTION',
        recoverable: true,
        severity: 'info'
      },
      [this.ERROR_TYPES.INSUFFICIENT_FUNDS]: {
        userMessage: 'Insufficient ICP balance for this transaction.',
        action: 'ADD_FUNDS',
        recoverable: true,
        severity: 'warning'
      },
      [this.ERROR_TYPES.SESSION_EXPIRED]: {
        userMessage: 'Your session has expired. Please reconnect your wallet.',
        action: 'RECONNECT',
        recoverable: true,
        severity: 'info'
      }
    };

    return errorResponses[errorType] || {
      userMessage: 'An unexpected error occurred. Please try again.',
      action: 'CONTACT_SUPPORT',
      recoverable: false,
      severity: 'error'
    };
  }

  static async withRetry<T>(
    operation: () => Promise<T>,
    options: { maxRetries?: number; delay?: number } = {}
  ): Promise<T> {
    const { maxRetries = 3, delay = 1000 } = options;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        if (attempt === maxRetries) throw error;
        
        const errorResponse = this.handleError(error);
        if (!errorResponse.recoverable) throw error;
        
        await new Promise(resolve => 
          setTimeout(resolve, delay * Math.pow(2, attempt - 1))
        );
      }
    }
    throw new Error('Max retries exceeded');
  }
}
```

### State Management with Connection Persistence

```typescript
class WalletStateManager {
  private state: Map<string, any> = new Map();
  private listeners: Set<(state: any) => void> = new Set();

  async maintainConnection() {
    // Check connection status periodically
    setInterval(async () => {
      if (window.ic?.plug) {
        const isConnected = await window.ic.plug.isConnected();
        
        if (!isConnected && this.state.get('wasConnected')) {
          // Attempt automatic reconnection
          await this.reconnect();
        }
        
        this.updateState('isConnected', isConnected);
      }
    }, 5000);
  }

  private async reconnect() {
    const whitelist = this.state.get('whitelist');
    const host = this.state.get('host');
    
    if (whitelist && host) {
      try {
        await window.ic.plug.requestConnect({ whitelist, host });
        
        if (!window.ic.plug.agent) {
          await window.ic.plug.createAgent({ whitelist, host });
        }
        
        this.updateState('isConnected', true);
      } catch (error) {
        console.error('Auto-reconnection failed:', error);
      }
    }
  }

  updateState(key: string, value: any) {
    this.state.set(key, value);
    this.notifyListeners();
  }

  private notifyListeners() {
    const stateObject = Object.fromEntries(this.state);
    this.listeners.forEach(listener => listener(stateObject));
  }
}
```

## Principal management and identity delegation capabilities

### Principal Management System

Plug Wallet uses a unified principal system, unlike II's per-dApp identities:

```typescript
class PrincipalManager {
  private principal: Principal | null = null;
  private accountId: string | null = null;

  async initialize() {
    if (!window.ic?.plug?.agent) {
      throw new Error('Plug agent not initialized');
    }

    this.principal = await window.ic.plug.agent.getPrincipal();
    this.accountId = window.ic.plug.accountId;
  }

  getPrincipalString(): string {
    return this.principal?.toString() || '';
  }

  getAccountId(): string {
    return this.accountId || '';
  }

  // Format principal for display
  formatPrincipal(principal: string): string {
    if (principal.length <= 16) return principal;
    return `${principal.slice(0, 8)}...${principal.slice(-6)}`;
  }

  // Generate subaccounts for different purposes
  generateSubaccount(index: number): Uint8Array {
    const subaccount = new Uint8Array(32);
    subaccount[31] = index;
    return subaccount;
  }
}
```

### Identity Delegation Implementation

While Plug doesn't use II's delegation chains, it provides agent-based authentication:

```typescript
class PlugIdentityDelegation {
  async createDelegatedActor(canisterId: string, idlFactory: IDL.InterfaceFactory) {
    // Plug handles delegation internally through its agent
    const actor = await window.ic.plug.createActor({
      canisterId,
      interfaceFactory: idlFactory
    });

    // Wrap actor with additional delegation logic if needed
    return new Proxy(actor, {
      get: (target, prop) => {
        if (typeof target[prop] === 'function') {
          return async (...args: any[]) => {
            // Add pre-execution checks
            await this.verifyDelegation();
            
            // Execute method
            const result = await target[prop](...args);
            
            // Post-execution logging
            this.logDelegatedAction(prop.toString(), args, result);
            
            return result;
          };
        }
        return target[prop];
      }
    });
  }

  private async verifyDelegation() {
    const isConnected = await window.ic.plug.isConnected();
    if (!isConnected) {
      throw new Error('Wallet delegation expired or revoked');
    }
  }

  private logDelegatedAction(method: string, args: any[], result: any) {
    console.log('Delegated action executed:', {
      method,
      args,
      result,
      timestamp: Date.now(),
      principal: window.ic.plug.principalId
    });
  }
}
```

## Limitations compared to ICP Identity

**Privacy limitations**: Plug uses a single Principal ID across all applications, making user activity trackable across dApps, unlike II's unlinkable per-application identities.

**Hardware security differences**: II leverages device TPM/HSM chips for hardware-backed security, while Plug relies on software-based seed phrase storage, potentially less secure against sophisticated attacks.

**Session management constraints**: Plug maintains persistent sessions requiring manual disconnection, lacking II's automatic 30-minute timeout and delegation chain expiration for enhanced security.

**Recovery mechanism differences**: Plug relies solely on 12-word seed phrases for recovery, while II supports multiple passkeys, hardware keys, and recovery phrases, providing more redundancy.

**Cross-device synchronization**: II seamlessly adds unlimited devices through its identity anchor system, while Plug requires manual seed phrase import on each device, creating potential security risks during transfer.

## UI/UX implementation patterns

### Connection Flow UI Component

```tsx
import React, { useState } from 'react';
import { usePlugWallet } from './hooks/usePlugWallet';

const WalletConnectionUI: React.FC = () => {
  const { 
    isConnected, 
    isConnecting, 
    principal, 
    balance, 
    error, 
    connect, 
    disconnect 
  } = usePlugWallet(['canister-id']);
  
  const [showDetails, setShowDetails] = useState(false);

  if (!isConnected) {
    return (
      <div className="wallet-connection">
        <button 
          onClick={connect}
          disabled={isConnecting}
          className="connect-btn"
        >
          {isConnecting ? (
            <>
              <span className="spinner" />
              Connecting to Plug...
            </>
          ) : (
            <>
              <img src="/plug-logo.svg" alt="Plug" />
              Connect Wallet
            </>
          )}
        </button>
        
        {error && (
          <div className="error-message">
            <span className="error-icon">â ï¸</span>
            {error}
          </div>
        )}
      </div>
    );
  }

  return (
    <div className="wallet-connected">
      <button 
        onClick={() => setShowDetails(!showDetails)}
        className="wallet-status"
      >
        <div className="status-indicator" />
        <span className="principal">
          {principal?.slice(0, 8)}...{principal?.slice(-6)}
        </span>
        <span className="balance">
          {balance?.[0]?.amount 
            ? `${(balance[0].amount / 100000000).toFixed(4)} ICP` 
            : 'Loading...'}
        </span>
      </button>

      {showDetails && (
        <div className="wallet-dropdown">
          <div className="dropdown-item">
            <span>Principal ID</span>
            <button 
              onClick={() => navigator.clipboard.writeText(principal || '')}
              className="copy-btn"
            >
              Copy
            </button>
          </div>
          
          <div className="dropdown-item">
            <span>Account ID</span>
            <span className="account-id">
              {window.ic.plug.accountId?.slice(0, 16)}...
            </span>
          </div>

          <button 
            onClick={disconnect}
            className="disconnect-btn"
          >
            Disconnect Wallet
          </button>
        </div>
      )}
    </div>
  );
};
```

### Transaction Confirmation Modal

```tsx
const TransactionConfirmation: React.FC<{
  transaction: TransactionDetails;
  onConfirm: () => void;
  onCancel: () => void;
}> = ({ transaction, onConfirm, onCancel }) => {
  const [isProcessing, setIsProcessing] = useState(false);

  const handleConfirm = async () => {
    setIsProcessing(true);
    try {
      await onConfirm();
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <div className="transaction-modal">
      <h3>Confirm Transaction</h3>
      
      <div className="transaction-details">
        <div className="detail-row">
          <span>To:</span>
          <span className="address">{transaction.to}</span>
        </div>
        
        <div className="detail-row">
          <span>Amount:</span>
          <span className="amount">{transaction.amount} ICP</span>
        </div>
        
        <div className="detail-row">
          <span>Network Fee:</span>
          <span className="fee">0.0001 ICP</span>
        </div>
        
        <div className="detail-row total">
          <span>Total:</span>
          <span>{transaction.amount + 0.0001} ICP</span>
        </div>
      </div>

      <div className="warning">
        â ï¸ This transaction cannot be reversed
      </div>

      <div className="modal-actions">
        <button 
          onClick={onCancel}
          disabled={isProcessing}
          className="btn-secondary"
        >
          Cancel
        </button>
        
        <button 
          onClick={handleConfirm}
          disabled={isProcessing}
          className="btn-primary"
        >
          {isProcessing ? 'Processing...' : 'Confirm'}
        </button>
      </div>
    </div>
  );
};
```

## Security implementation essentials

### Secure Wallet Connection Pattern

```typescript
class SecurePlugConnection {
  private readonly REQUIRED_CANISTERS: string[] = [];
  private readonly TRUSTED_HOSTS = [
    'https://mainnet.dfinity.network',
    'https://ic0.app',
    'https://icp0.io'
  ];

  async secureConnect(canisters: string[]): Promise<boolean> {
    // Validate environment
    if (!this.isSecureContext()) {
      throw new Error('Wallet connection requires HTTPS');
    }

    // Validate canister IDs
    for (const canisterId of canisters) {
      if (!this.isValidCanisterId(canisterId)) {
        throw new Error(`Invalid canister ID: ${canisterId}`);
      }
    }

    // Check Plug availability
    if (!window.ic?.plug) {
      throw new Error('Plug wallet not detected');
    }

    try {
      // Request connection with validated whitelist
      const publicKey = await window.ic.plug.requestConnect({
        whitelist: canisters,
        host: this.TRUSTED_HOSTS[0],
        timeout: 30000
      });

      // Verify principal
      const principal = await window.ic.plug.agent.getPrincipal();
      if (!principal || principal.isAnonymous()) {
        throw new Error('Invalid or anonymous principal');
      }

      return true;
    } catch (error) {
      this.handleSecurityError(error);
      return false;
    }
  }

  private isSecureContext(): boolean {
    return window.isSecureContext && window.location.protocol === 'https:';
  }

  private isValidCanisterId(canisterId: string): boolean {
    // Validate canister ID format
    const pattern = /^[a-z0-9]{5}-[a-z0-9]{5}-[a-z0-9]{5}-[a-z0-9]{5}-[a-z0-9]{3}$/;
    return pattern.test(canisterId);
  }

  private handleSecurityError(error: Error) {
    // Log security events for monitoring
    console.error('Security error during wallet connection:', {
      error: error.message,
      timestamp: Date.now(),
      userAgent: navigator.userAgent
    });
  }
}
```

### Transaction Security Implementation

```typescript
class SecureTransactionManager {
  private locks = new Map<string, boolean>();

  async executeSecureTransaction<T>(
    operation: () => Promise<T>,
    options: {
      requireConfirmation?: boolean;
      maxRetries?: number;
      timeout?: number;
    } = {}
  ): Promise<T> {
    const {
      requireConfirmation = true,
      maxRetries = 3,
      timeout = 30000
    } = options;

    // Prevent reentrancy
    const lockKey = `tx-${Date.now()}`;
    if (this.locks.has(lockKey)) {
      throw new Error('Transaction already in progress');
    }

    this.locks.set(lockKey, true);

    try {
      // Validate connection
      const isConnected = await window.ic.plug.isConnected();
      if (!isConnected) {
        throw new Error('Wallet not connected');
      }

      // Execute with timeout
      const result = await Promise.race([
        operation(),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Transaction timeout')), timeout)
        )
      ]);

      return result as T;
    } finally {
      this.locks.delete(lockKey);
    }
  }
}
```

### Permission Management System

```typescript
class PermissionManager {
  private permissions = new Map<string, Set<string>>();

  async requestPermissions(canisters: string[]): Promise<boolean> {
    // Check existing permissions
    const existingPermissions = await this.getExistingPermissions();
    const newPermissions = canisters.filter(c => !existingPermissions.includes(c));

    if (newPermissions.length > 0) {
      // Request new permissions
      const granted = await window.ic.plug.requestConnect({
        whitelist: [...existingPermissions, ...newPermissions]
      });

      if (granted) {
        // Update permission store
        const principal = window.ic.plug.principalId;
        this.permissions.set(principal, new Set(canisters));
        return true;
      }
    }

    return existingPermissions.length === canisters.length;
  }

  private async getExistingPermissions(): Promise<string[]> {
    // This would ideally check against Plug's internal whitelist
    // For now, return empty array as Plug doesn't expose this
    return [];
  }

  hasPermission(canisterId: string): boolean {
    const principal = window.ic.plug.principalId;
    return this.permissions.get(principal)?.has(canisterId) || false;
  }
}
```

## Complete migration checklist

### Pre-Migration Phase
- [ ] **Audit current II integration** - Document all authentication touchpoints
- [ ] **Map user data structures** - Identify data tied to II principals
- [ ] **Design migration strategy** - Choose between parallel support or phased migration
- [ ] **Create data export/import tools** - Build canister methods for data migration
- [ ] **Set up GitHub Package Registry** - Configure .npmrc for Plug SDK access
- [ ] **Test in local environment** - Verify basic Plug connection works

### Implementation Phase
- [ ] **Install Plug SDK packages** - Add @psychedelic/plug-connect and dependencies
- [ ] **Implement usePlugWallet hook** - Create custom React hook for wallet management
- [ ] **Build dual authentication manager** - Support both II and Plug during transition
- [ ] **Create actor abstraction layer** - Unified interface for both auth methods
- [ ] **Implement error handling** - Comprehensive error management system
- [ ] **Add connection persistence** - Handle reconnection and session management
- [ ] **Build UI components** - Connection button, status display, transaction modals
- [ ] **Implement security measures** - Canister whitelisting, input validation, CORS

### Migration Execution
- [ ] **Deploy dual-auth version** - Release with both authentication options
- [ ] **Create migration guides** - User documentation for switching wallets
- [ ] **Implement data migration tools** - One-click data transfer between identities
- [ ] **Monitor migration metrics** - Track user adoption and issues
- [ ] **Provide user support** - Help desk for migration questions
- [ ] **Handle edge cases** - Account linking, partial migrations

### Post-Migration Phase
- [ ] **Deprecate II authentication** - Gradually phase out after majority migrates
- [ ] **Optimize Plug-only flows** - Remove abstraction layers
- [ ] **Update documentation** - Remove II references, focus on Plug
- [ ] **Performance optimization** - Fine-tune for single auth method
- [ ] **Security audit** - Full review of new authentication system

## Performance and optimization considerations

**Connection optimization** involves maintaining persistent agent instances to avoid repeated initialization, implementing connection pooling for multiple canister interactions, and using lazy loading for wallet SDK to improve initial page load.

**State management efficiency** requires minimizing wallet state checks with appropriate caching, implementing debouncing for balance updates to reduce API calls, and using React.memo and useMemo for expensive computations.

**Transaction batching** leverages Plug's batchTransactions for multiple operations, reducing user approval fatigue and network overhead while implementing queue management for sequential dependencies.

**Error recovery optimization** includes implementing exponential backoff for failed requests, maintaining fallback connection methods, and caching successful connections for faster reconnection.

This comprehensive guide provides everything needed to successfully migrate from Internet Identity to Plug Wallet, with production-ready code examples, security best practices, and detailed implementation patterns. The migration requires careful planning due to fundamental architectural differences, but the provided patterns enable a smooth transition while maintaining application functionality and user experience.